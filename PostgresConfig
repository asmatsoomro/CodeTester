spring:
  datasource:
    url: jdbc:postgresql://localhost:5432/mydatabase
    username: myusername
    password: mypassword
    driver-class-name: org.postgresql.Driver
  jpa:
    properties:
      hibernate:
        dialect: org.hibernate.dialect.PostgreSQLDialect
        connection:
          provider_disables_autocommit: true
          provider_class: org.hibernate.hikaricp.internal.HikariCPConnectionProvider
          url: jdbc:postgresql://localhost:5432/mydatabase
          username: myusername
          password: mypassword
          driver_class: org.postgresql.Driver
          hikari:
            connectionTimeout: 20000
      ssl: true
      sslfactory: org.postgresql.ssl.NonValidatingFactory
      sslrootcert: /path/to/ca.crt
      sslcert: /path/to/client.crt
      sslkey: /path/to/client.key

implementation 'org.springframework.boot:spring-boot-starter-data-jpa'
implementation 'org.postgresql:postgresql'


import org.springframework.boot.context.properties.ConfigurationProperties
import org.springframework.boot.jdbc.DataSourceBuilder
import org.springframework.context.annotation.Bean
import org.springframework.context.annotation.Configuration
import javax.sql.DataSource

@Configuration
class PostgresConfiguration {

    @Bean
    @ConfigurationProperties(prefix = "spring.datasource")
    fun dataSource(): DataSource {
        return DataSourceBuilder.create().build()
    }
}

import org.springframework.beans.factory.annotation.Value
import org.springframework.boot.context.properties.ConfigurationProperties
import org.springframework.boot.jdbc.DataSourceBuilder
import org.springframework.context.annotation.Bean
import org.springframework.context.annotation.Configuration
import org.springframework.context.annotation.Primary
import org.springframework.orm.jpa.JpaTransactionManager
import org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean
import org.springframework.transaction.PlatformTransactionManager
import org.springframework.transaction.annotation.EnableTransactionManagement
import java.io.FileInputStream
import java.security.KeyStore
import javax.persistence.EntityManagerFactory
import javax.sql.DataSource

@Configuration
@EnableTransactionManagement
class DatabaseConfiguration {
    @Value("\${spring.datasource.url}")
    private lateinit var url: String

    @Value("\${spring.datasource.username}")
    private lateinit var username: String

    @Value("\${spring.datasource.password}")
    private lateinit var password: String

    @Value("\${keystore.path}")
    private lateinit var keystorePath: String

    @Value("\${keystore.password}")
    private lateinit var keystorePassword: String

    @Bean
    @Primary
    @ConfigurationProperties(prefix = "spring.datasource")
    fun dataSource(): DataSource {
        val sslFactory = SSLFactory.Builder()
            .withDefaultTrustMaterial()
            .withIdentityMaterial(keystorePath, keystorePassword.toCharArray())
            .build()

        return DataSourceBuilder.create()
            .url(url)
            .username(username)
            .password(password)
            .sslFactory(sslFactory)
            .build()
    }

    @Bean
    @Primary
    fun entityManagerFactory(dataSource: DataSource): LocalContainerEntityManagerFactoryBean {
        val entityManagerFactoryBean = LocalContainerEntityManagerFactoryBean()
        entityManagerFactoryBean.dataSource = dataSource
        return entityManagerFactoryBean
    }

    @Bean
    @Primary
    fun transactionManager(entityManagerFactory: EntityManagerFactory): PlatformTransactionManager {
        return JpaTransactionManager(entityManagerFactory)
        
        
        spring:
  datasource:
    url: jdbc:postgresql://localhost:5432/dbname?ssl=true&sslmode=require&sslcert=/path/to/client.crt&sslkey=/path/to/client.key&sslrootcert=/path/to/root.crt

spring:
  jpa:
    hibernate:
      ddl-auto: update
      dialect: org.hibernate.dialect.PostgreSQLDialect
      show-sql:
      
      
      entityManagerFactoryBean.jpaPropertyMap = mapOf(
    "hibernate.dialect" to "org.hibernate.dialect.PostgreSQLDialect",
    "hibernate.hbm2ddl.auto" to "update",
    "hibernate.show_sql" to "true",
    "hibernate.format_sql" to "true",
    "hibernate.temp.use_jdbc_metadata_defaults" to "false",
    "hibernate.connection.provider_disables_autocommit" to "true",
    "hibernate.physical_naming_strategy" to "org.springframework.boot.orm.jpa.hibernate.SpringPhysicalNamingStrategy",
    "hibernate.implicit_naming_strategy" to "org.springframework.boot.orm.jpa.hibernate.SpringImplicitNamingStrategy"
)


import com.zaxxer.hikari.HikariDataSource
import org.springframework.beans.factory.annotation.Value
import org.springframework.context.annotation.Bean
import org.springframework.context.annotation.Configuration
import javax.sql.DataSource

@Configuration
class DatabaseConfig {

    @Value("\${spring.datasource.url}")
    private lateinit var url: String

    @Value("\${spring.datasource.username}")
    private lateinit var username: String

    @Value("\${spring.datasource.password}")
    private lateinit var password: String

    @Value("\${spring.datasource.driver-class-name}")
    private lateinit var driverClassName: String

    @Value("\${spring.datasource.ssl.enabled}")
    private var sslEnabled: Boolean = false

    @Value("\${spring.datasource.ssl.mode}")
    private lateinit var sslMode: String

    @Value("\${spring.datasource.ssl.root-certificate}")
    private lateinit var rootCertificatePath: String

    @Value("\${spring.datasource.ssl.client-certificate}")
    private lateinit var clientCertificatePath: String

    @Value("\${spring.datasource.ssl.client-key}")
    private lateinit var clientKeyPath: String

    @Bean
    fun dataSource(): DataSource {
        val dataSource = HikariDataSource()
        dataSource.jdbcUrl = url
        dataSource.username = username
        dataSource.password = password
        dataSource.driverClassName = driverClassName

        if (sslEnabled) {
            dataSource.addDataSourceProperty("sslmode", sslMode)
            dataSource.addDataSourceProperty("sslrootcert", rootCertificatePath)
            dataSource.addDataSourceProperty("sslcert", clientCertificatePath)
            dataSource.addDataSourceProperty("sslkey", clientKeyPath)
        }

        return dataSource
    }
}

   

