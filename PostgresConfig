spring:
  datasource:
    url: jdbc:postgresql://localhost:5432/mydatabase
    username: myusername
    password: mypassword
    driver-class-name: org.postgresql.Driver
  jpa:
    properties:
      hibernate:
        dialect: org.hibernate.dialect.PostgreSQLDialect
        connection:
          provider_disables_autocommit: true
          provider_class: org.hibernate.hikaricp.internal.HikariCPConnectionProvider
          url: jdbc:postgresql://localhost:5432/mydatabase
          username: myusername
          password: mypassword
          driver_class: org.postgresql.Driver
          hikari:
            connectionTimeout: 20000
      ssl: true
      sslfactory: org.postgresql.ssl.NonValidatingFactory
      sslrootcert: /path/to/ca.crt
      sslcert: /path/to/client.crt
      sslkey: /path/to/client.key

implementation 'org.springframework.boot:spring-boot-starter-data-jpa'
implementation 'org.postgresql:postgresql'


import org.springframework.boot.context.properties.ConfigurationProperties
import org.springframework.boot.jdbc.DataSourceBuilder
import org.springframework.context.annotation.Bean
import org.springframework.context.annotation.Configuration
import javax.sql.DataSource

@Configuration
class PostgresConfiguration {

    @Bean
    @ConfigurationProperties(prefix = "spring.datasource")
    fun dataSource(): DataSource {
        return DataSourceBuilder.create().build()
    }
}

import org.springframework.beans.factory.annotation.Value
import org.springframework.boot.context.properties.ConfigurationProperties
import org.springframework.boot.jdbc.DataSourceBuilder
import org.springframework.context.annotation.Bean
import org.springframework.context.annotation.Configuration
import org.springframework.context.annotation.Primary
import org.springframework.orm.jpa.JpaTransactionManager
import org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean
import org.springframework.transaction.PlatformTransactionManager
import org.springframework.transaction.annotation.EnableTransactionManagement
import java.io.FileInputStream
import java.security.KeyStore
import javax.persistence.EntityManagerFactory
import javax.sql.DataSource

@Configuration
@EnableTransactionManagement
class DatabaseConfiguration {
    @Value("\${spring.datasource.url}")
    private lateinit var url: String

    @Value("\${spring.datasource.username}")
    private lateinit var username: String

    @Value("\${spring.datasource.password}")
    private lateinit var password: String

    @Value("\${keystore.path}")
    private lateinit var keystorePath: String

    @Value("\${keystore.password}")
    private lateinit var keystorePassword: String

    @Bean
    @Primary
    @ConfigurationProperties(prefix = "spring.datasource")
    fun dataSource(): DataSource {
        val sslFactory = SSLFactory.Builder()
            .withDefaultTrustMaterial()
            .withIdentityMaterial(keystorePath, keystorePassword.toCharArray())
            .build()

        return DataSourceBuilder.create()
            .url(url)
            .username(username)
            .password(password)
            .sslFactory(sslFactory)
            .build()
    }

    @Bean
    @Primary
    fun entityManagerFactory(dataSource: DataSource): LocalContainerEntityManagerFactoryBean {
        val entityManagerFactoryBean = LocalContainerEntityManagerFactoryBean()
        entityManagerFactoryBean.dataSource = dataSource
        return entityManagerFactoryBean
    }

    @Bean
    @Primary
    fun transactionManager(entityManagerFactory: EntityManagerFactory): PlatformTransactionManager {
        return JpaTransactionManager(entityManagerFactory)
        
        
        spring:
  datasource:
    url: jdbc:postgresql://localhost:5432/dbname?ssl=true&sslmode=require&sslcert=/path/to/client.crt&sslkey=/path/to/client.key&sslrootcert=/path/to/root.crt

spring:
  jpa:
    hibernate:
      ddl-auto: update
      dialect: org.hibernate.dialect.PostgreSQLDialect
      show-sql:

   

